/*!
    localForage -- Offline Storage, Improved
    Version 1.5.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!(function (a) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = a(); else if (typeof define === 'function' && define.amd)define([], a); else { let b; b = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this, b.localforage = a(); } }(() => (function a(b, c, d) { function e(g, h) { if (!c[g]) { if (!b[g]) { const i = typeof require === 'function' && require; if (!h && i) return i(g, !0); if (f) return f(g, !0); const j = new Error(`Cannot find module '${g}'`); throw j.code = 'MODULE_NOT_FOUND', j; } const k = c[g] = { exports: {} }; b[g][0].call(k.exports, (a) => { const c = b[g][1][a]; return e(c || a); }, k, k.exports, a, b, c, d); } return c[g].exports; } for (var f = typeof require === 'function' && require, g = 0; g < d.length; g++)e(d[g]); return e; }({ 1: [function (a, b, c) {
  (function (a) {
    function c() { k = !0; for (var a, b, c = l.length; c;) { for (b = l, l = [], a = -1; ++a < c;)b[a](); c = l.length; }k = !1; } function d(a) { l.push(a) !== 1 || k || e(); } let e,
      f = a.MutationObserver || a.WebKitMutationObserver; if (f) {
      let g = 0,
        h = new f(c),
        i = a.document.createTextNode(''); h.observe(i, { characterData: !0 }), e = function () { i.data = g = ++g % 2; };
    } else if (a.setImmediate || typeof a.MessageChannel === 'undefined')e = 'document' in a && 'onreadystatechange' in a.document.createElement('script') ? function () { let b = a.document.createElement('script'); b.onreadystatechange = function () { c(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null; }, a.document.documentElement.appendChild(b); } : function () { setTimeout(c, 0); }; else { const j = new a.MessageChannel(); j.port1.onmessage = c, e = function () { j.port2.postMessage(0); }; } var k,
      l = []; b.exports = d;
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
}, {}],
2: [function (a, b, c) {
  function d() {} function e(a) { if (typeof a !== 'function') throw new TypeError('resolver must be a function'); this.state = s, this.queue = [], this.outcome = void 0, a !== d && i(this, a); } function f(a, b, c) { this.promise = a, typeof b === 'function' && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), typeof c === 'function' && (this.onRejected = c, this.callRejected = this.otherCallRejected); } function g(a, b, c) { o(() => { let d; try { d = b(c); } catch (b) { return p.reject(a, b); }d === a ? p.reject(a, new TypeError('Cannot resolve promise with itself')) : p.resolve(a, d); }); } function h(a) { const b = a && a.then; if (a && typeof a === 'object' && typeof b === 'function') return function () { b.apply(a, arguments); }; } function i(a, b) {
    function c(b) { f || (f = !0, p.reject(a, b)); } function d(b) { f || (f = !0, p.resolve(a, b)); } function e() { b(d, c); } var f = !1,
      g = j(e); g.status === 'error' && c(g.value);
  } function j(a, b) { const c = {}; try { c.value = a(b), c.status = 'success'; } catch (a) { c.status = 'error', c.value = a; } return c; } function k(a) { return a instanceof this ? a : p.resolve(new this(d), a); } function l(a) { const b = new this(d); return p.reject(b, a); } function m(a) {
    function b(a, b) { function d(a) { g[b] = a, ++h !== e || f || (f = !0, p.resolve(j, g)); }c.resolve(a).then(d, (a) => { f || (f = !0, p.reject(j, a)); }); } var c = this; if (Object.prototype.toString.call(a) !== '[object Array]') return this.reject(new TypeError('must be an array')); var e = a.length,
      f = !1; if (!e) return this.resolve([]); for (var g = new Array(e), h = 0, i = -1, j = new this(d); ++i < e;)b(a[i], i); return j;
  } function n(a) {
    function b(a) { c.resolve(a).then((a) => { f || (f = !0, p.resolve(h, a)); }, (a) => { f || (f = !0, p.reject(h, a)); }); } var c = this; if (Object.prototype.toString.call(a) !== '[object Array]') return this.reject(new TypeError('must be an array')); var e = a.length,
      f = !1; if (!e) return this.resolve([]); for (var g = -1, h = new this(d); ++g < e;)b(a[g]); return h;
  } var o = a(1),
    p = {},
    q = ['REJECTED'],
    r = ['FULFILLED'],
    s = ['PENDING']; b.exports = c = e, e.prototype.catch = function (a) { return this.then(null, a); }, e.prototype.then = function (a, b) { if (typeof a !== 'function' && this.state === r || typeof b !== 'function' && this.state === q) return this; const c = new this.constructor(d); if (this.state !== s) { const e = this.state === r ? a : b; g(c, e, this.outcome); } else this.queue.push(new f(c, a, b)); return c; }, f.prototype.callFulfilled = function (a) { p.resolve(this.promise, a); }, f.prototype.otherCallFulfilled = function (a) { g(this.promise, this.onFulfilled, a); }, f.prototype.callRejected = function (a) { p.reject(this.promise, a); }, f.prototype.otherCallRejected = function (a) { g(this.promise, this.onRejected, a); }, p.resolve = function (a, b) { const c = j(h, b); if (c.status === 'error') return p.reject(a, c.value); const d = c.value; if (d)i(a, d); else { a.state = r, a.outcome = b; for (let e = -1, f = a.queue.length; ++e < f;)a.queue[e].callFulfilled(b); } return a; }, p.reject = function (a, b) { a.state = q, a.outcome = b; for (let c = -1, d = a.queue.length; ++c < d;)a.queue[c].callRejected(b); return a; }, c.resolve = k, c.reject = l, c.all = m, c.race = n;
}, { 1: 1 }],
3: [function (a, b, c) {
  (function (b) {
    typeof b.Promise !== 'function' && (b.Promise = a(2));
  }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
}, { 2: 2 }],
4: [function (a, b, c) {
  function d(a, b) { if (!(a instanceof b)) throw new TypeError('Cannot call a class as a function'); } function e() { try { if (typeof indexedDB !== 'undefined') return indexedDB; if (typeof webkitIndexedDB !== 'undefined') return webkitIndexedDB; if (typeof mozIndexedDB !== 'undefined') return mozIndexedDB; if (typeof OIndexedDB !== 'undefined') return OIndexedDB; if (typeof msIndexedDB !== 'undefined') return msIndexedDB; } catch (a) {} } function f() {
    try {
      if (!ga) return !1; let a = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform),
        b = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1; return (!a || b) && typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
    } catch (a) { return !1; }
  } function g() { return typeof openDatabase === 'function'; } function h() { try { return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem; } catch (a) { return !1; } } function i(a, b) { a = a || [], b = b || {}; try { return new Blob(a, b); } catch (f) { if (f.name !== 'TypeError') throw f; for (var c = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder, d = new c(), e = 0; e < a.length; e += 1)d.append(a[e]); return d.getBlob(b.type); } } function j(a, b) { b && a.then((a) => { b(null, a); }, (a) => { b(a); }); } function k(a, b, c) { typeof b === 'function' && a.then(b), typeof c === 'function' && a.catch(c); } function l(a) { for (var b = a.length, c = new ArrayBuffer(b), d = new Uint8Array(c), e = 0; e < b; e++)d[e] = a.charCodeAt(e); return c; } function m(a) {
    return new ja(((b) => {
      let c = a.transaction(ka, 'readwrite'),
        d = i(['']); c.objectStore(ka).put(d, 'key'), c.onabort = function (a) { a.preventDefault(), a.stopPropagation(), b(!1); }, c.oncomplete = function () {
        let a = navigator.userAgent.match(/Chrome\/(\d+)/),
          c = navigator.userAgent.match(/Edge\//); b(c || !a || parseInt(a[1], 10) >= 43);
      };
    })).catch(() => !1);
  } function n(a) { return typeof ha === 'boolean' ? ja.resolve(ha) : m(a).then(a => ha = a); } function o(a) {
    let b = ia[a.name],
      c = {}; c.promise = new ja(((a) => { c.resolve = a; })), b.deferredOperations.push(c), b.dbReady ? b.dbReady = b.dbReady.then(() => c.promise) : b.dbReady = c.promise;
  } function p(a) {
    let b = ia[a.name],
      c = b.deferredOperations.pop(); c && c.resolve();
  } function q(a, b) { return new ja(((c, d) => { if (a.db) { if (!b) return c(a.db); o(a), a.db.close(); } const e = [a.name]; b && e.push(a.version); const f = ga.open(...e); b && (f.onupgradeneeded = function (b) { const c = f.result; try { c.createObjectStore(a.storeName), b.oldVersion <= 1 && c.createObjectStore(ka); } catch (c) { if (c.name !== 'ConstraintError') throw c; console.warn(`The database "${a.name}" has been upgraded from version ${b.oldVersion} to version ${b.newVersion}, but the storage "${a.storeName}" already exists.`); } }), f.onerror = function (a) { a.preventDefault(), d(f.error); }, f.onsuccess = function () { c(f.result), p(a); }; })); } function r(a) { return q(a, !1); } function s(a) { return q(a, !0); } function t(a, b) {
    if (!a.db) return !0; let c = !a.db.objectStoreNames.contains(a.storeName),
      d = a.version < a.db.version,
      e = a.version > a.db.version; if (d && (a.version !== b && console.warn(`The database "${a.name}" can't be downgraded from version ${a.db.version} to version ${a.version}.`), a.version = a.db.version), e || c) { if (c) { const f = a.db.version + 1; f > a.version && (a.version = f); } return !0; } return !1;
  } function u(a) { return new ja(((b, c) => { const d = new FileReader(); d.onerror = c, d.onloadend = function (c) { const d = btoa(c.target.result || ''); b({ __local_forage_encoded_blob: !0, data: d, type: a.type }); }, d.readAsBinaryString(a); })); } function v(a) { const b = l(atob(a.data)); return i([b], { type: a.type }); } function w(a) { return a && a.__local_forage_encoded_blob; } function x(a) {
    let b = this,
      c = b._initReady().then(() => { const a = ia[b._dbInfo.name]; if (a && a.dbReady) return a.dbReady; }); return k(c, a, a), c;
  } function y(a) {
    function b() { return ja.resolve(); } let c = this,
      d = { db: null }; if (a) for (const e in a)d[e] = a[e]; ia || (ia = {}); let f = ia[d.name]; f || (f = { forages: [], db: null, dbReady: null, deferredOperations: [] }, ia[d.name] = f), f.forages.push(c), c._initReady || (c._initReady = c.ready, c.ready = x); for (var g = [], h = 0; h < f.forages.length; h++) { const i = f.forages[h]; i !== c && g.push(i._initReady().catch(b)); } const j = f.forages.slice(0); return ja.all(g).then(() => d.db = f.db, r(d)).then(a => d.db = a, t(d, c._defaultConfig.version) ? s(d) : a).then((a) => { d.db = f.db = a, c._dbInfo = d; for (let b = 0; b < j.length; b++) { const e = j[b]; e !== c && (e._dbInfo.db = d.db, e._dbInfo.version = d.version); } });
  } function z(a, b) {
    const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = new ja(((b, d) => {
      c.ready().then(() => {
        let e = c._dbInfo,
          f = e.db.transaction(e.storeName, 'readonly').objectStore(e.storeName),
          g = f.get(a); g.onsuccess = function () { let a = g.result; void 0 === a && (a = null), w(a) && (a = v(a)), b(a); }, g.onerror = function () { d(g.error); };
      }).catch(d);
    })); return j(d, b), d;
  } function A(a, b) {
    let c = this,
      d = new ja(((b, d) => {
        c.ready().then(() => {
          let e = c._dbInfo,
            f = e.db.transaction(e.storeName, 'readonly').objectStore(e.storeName),
            g = f.openCursor(),
            h = 1; g.onsuccess = function () { const c = g.result; if (c) { let d = c.value; w(d) && (d = v(d)); const e = a(d, c.key, h++); void 0 !== e ? b(e) : c.continue(); } else b(); }, g.onerror = function () { d(g.error); };
        }).catch(d);
      })); return j(d, b), d;
  } function B(a, b, c) {
    const d = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const e = new ja(((c, e) => {
      let f; d.ready().then(() => f = d._dbInfo, la.call(b) === '[object Blob]' ? n(f.db).then(a => (a?b:u(b))) : b).then((b) => {
        let d = f.db.transaction(f.storeName, 'readwrite'),
          g = d.objectStore(f.storeName),
          h = g.put(b, a); b === null && (b = void 0), d.oncomplete = function () { void 0 === b && (b = null), c(b); }, d.onabort = d.onerror = function () { const a = h.error ? h.error : h.transaction.error; e(a); };
      }).catch(e);
    })); return j(e, c), e;
  } function C(a, b) {
    const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = new ja(((b, d) => {
      c.ready().then(() => {
        let e = c._dbInfo,
          f = e.db.transaction(e.storeName, 'readwrite'),
          g = f.objectStore(e.storeName),
          h = g.delete(a); f.oncomplete = function () { b(); }, f.onerror = function () { d(h.error); }, f.onabort = function () { const a = h.error ? h.error : h.transaction.error; d(a); };
      }).catch(d);
    })); return j(d, b), d;
  } function D(a) {
    let b = this,
      c = new ja(((a, c) => {
        b.ready().then(() => {
          let d = b._dbInfo,
            e = d.db.transaction(d.storeName, 'readwrite'),
            f = e.objectStore(d.storeName),
            g = f.clear(); e.oncomplete = function () { a(); }, e.onabort = e.onerror = function () { const a = g.error ? g.error : g.transaction.error; c(a); };
        }).catch(c);
      })); return j(c, a), c;
  } function E(a) {
    let b = this,
      c = new ja(((a, c) => {
        b.ready().then(() => {
          let d = b._dbInfo,
            e = d.db.transaction(d.storeName, 'readonly').objectStore(d.storeName),
            f = e.count(); f.onsuccess = function () { a(f.result); }, f.onerror = function () { c(f.error); };
        }).catch(c);
      })); return j(c, a), c;
  } function F(a, b) {
    let c = this,
      d = new ja(((b, d) => (a < 0 ? void b(null) : void c.ready().then(() => {
 let e = c._dbInfo, 
f = e.db.transaction(e.storeName, 'readonly').objectStore(e.storeName),
        g = !1,
        h = f.openCursor(); h.onsuccess = function () { let c = h.result; return c ? void (a === 0 ? b(c.key):g ? b(c.key) : (g = !0, c.advance(a))) : void b(null); }, h.onerror = function () { d(h.error); };
}).catch(d)))); return j(d, b), d;
  } function G(a) {
    let b = this,
      c = new ja(((a, c) => {
        b.ready().then(() => {
          let d = b._dbInfo,
            e = d.db.transaction(d.storeName, 'readonly').objectStore(d.storeName),
            f = e.openCursor(),
            g = []; f.onsuccess = function () { const b = f.result; return b ? (g.push(b.key), void b.continue()) : void a(g); }, f.onerror = function () { c(f.error); };
        }).catch(c);
      })); return j(c, a), c;
  } function H(a) {
    let b,
      c,
      d,
      e,
      f,
      g = 0.75 * a.length,
      h = a.length,
      i = 0; a[a.length - 1] === '=' && (g--, a[a.length - 2] === '=' && g--); let j = new ArrayBuffer(g),
      k = new Uint8Array(j); for (b = 0; b < h; b += 4)c = na.indexOf(a[b]), d = na.indexOf(a[b + 1]), e = na.indexOf(a[b + 2]), f = na.indexOf(a[b + 3]), k[i++] = c << 2 | d >> 4, k[i++] = (15 & d) << 4 | e >> 2, k[i++] = (3 & e) << 6 | 63 & f; return j;
  } function I(a) {
    let b,
      c = new Uint8Array(a),
      d = ''; for (b = 0; b < c.length; b += 3)d += na[c[b] >> 2], d += na[(3 & c[b]) << 4 | c[b + 1] >> 4], d += na[(15 & c[b + 1]) << 2 | c[b + 2] >> 6], d += na[63 & c[b + 2]]; return c.length % 3 === 2 ? d = `${d.substring(0, d.length - 1)}=` : c.length % 3 === 1 && (d = `${d.substring(0, d.length - 2)}==`), d;
  } function J(a, b) {
    let c = ''; if (a && (c = Ea.call(a)), a && (c === '[object ArrayBuffer]' || a.buffer && Ea.call(a.buffer) === '[object ArrayBuffer]')) {
      let d,
        e = qa; a instanceof ArrayBuffer ? (d = a, e += sa) : (d = a.buffer, c === '[object Int8Array]' ? e += ua : c === '[object Uint8Array]' ? e += va : c === '[object Uint8ClampedArray]' ? e += wa : c === '[object Int16Array]' ? e += xa : c === '[object Uint16Array]' ? e += za : c === '[object Int32Array]' ? e += ya : c === '[object Uint32Array]' ? e += Aa : c === '[object Float32Array]' ? e += Ba : c === '[object Float64Array]' ? e += Ca : b(new Error('Failed to get type for BinaryArray'))), b(e + I(d));
    } else if (c === '[object Blob]') { const f = new FileReader(); f.onload = function () { const c = `${oa + a.type}~${I(this.result)}`; b(qa + ta + c); }, f.readAsArrayBuffer(a); } else try { b(JSON.stringify(a)); } catch (c) { console.error("Couldn't convert value into a JSON string: ", a), b(null, c); }
  } function K(a) {
    if (a.substring(0, ra) !== qa) return JSON.parse(a); let b,
      c = a.substring(Da),
      d = a.substring(ra, Da); if (d === ta && pa.test(c)) { const e = c.match(pa); b = e[1], c = c.substring(e[0].length); } const f = H(c); switch (d) { case sa:return f; case ta:return i([f], { type: b }); case ua:return new Int8Array(f); case va:return new Uint8Array(f); case wa:return new Uint8ClampedArray(f); case xa:return new Int16Array(f); case za:return new Uint16Array(f); case ya:return new Int32Array(f); case Aa:return new Uint32Array(f); case Ba:return new Float32Array(f); case Ca:return new Float64Array(f); default:throw new Error(`Unkown type: ${d}`); }
  } function L(a) {
    let b = this,
      c = { db: null }; if (a) for (const d in a)c[d] = typeof a[d] !== 'string' ? a[d].toString() : a[d]; const e = new ja(((a, d) => { try { c.db = openDatabase(c.name, String(c.version), c.description, c.size); } catch (a) { return d(a); }c.db.transaction((e) => { e.executeSql(`CREATE TABLE IF NOT EXISTS ${c.storeName} (id INTEGER PRIMARY KEY, key unique, value)`, [], () => { b._dbInfo = c, a(); }, (a, b) => { d(b); }); }); })); return c.serializer = Fa, e;
  } function M(a, b) { const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = new ja(((b, d) => { c.ready().then(() => { const e = c._dbInfo; e.db.transaction((c) => { c.executeSql(`SELECT * FROM ${e.storeName} WHERE key = ? LIMIT 1`, [a], (a, c) => { let d = c.rows.length ? c.rows.item(0).value : null; d && (d = e.serializer.deserialize(d)), b(d); }, (a, b) => { d(b); }); }); }).catch(d); })); return j(d, b), d; } function N(a, b) {
    let c = this,
      d = new ja(((b, d) => {
        c.ready().then(() => {
          const e = c._dbInfo; e.db.transaction((c) => {
            c.executeSql(`SELECT * FROM ${e.storeName}`, [], (c, d) => {
 for (let f = d.rows, g = f.length, h = 0; h < g; h++) {
 let i = f.item(h),
              j = i.value; if (j && (j = e.serializer.deserialize(j)), j = a(j, i.key, h + 1), void 0 !== j) return void b(j);
}b(); 
}, (a, b) => { d(b); }); 
});
        }).catch(d);
      })); return j(d, b), d;
  } function O(a, b, c, d) {
    const e = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const f = new ja(((f, g) => {
      e.ready().then(() => {
        void 0 === b && (b = null); let h = b,
          i = e._dbInfo; i.serializer.serialize(b, (b, j) => { j ? g(j) : i.db.transaction((c) => { c.executeSql(`INSERT OR REPLACE INTO ${i.storeName  } (key, value) VALUES (?, ?)`, [a, b], () => { f(h);}, (a, b) => { g(b) }); }, (b) => { if (b.code === b.QUOTA_ERR) { if (d > 0) return void f(O.apply(e, [a, h, c, d - 1])); g(b); } }); });
      }).catch(g);
    })); return j(f, c), f;
  } function P(a, b, c) { return O.apply(this, [a, b, c, 1]); } function Q(a, b) { const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = new ja(((b, d) => { c.ready().then(() => { const e = c._dbInfo; e.db.transaction((c) => { c.executeSql(`DELETE FROM ${e.storeName} WHERE key = ?`, [a], () => { b(); }, (a, b) => { d(b); }); }); }).catch(d); })); return j(d, b), d; } function R(a) {
    let b = this,
      c = new ja(((a, c) => { b.ready().then(() => { const d = b._dbInfo; d.db.transaction((b) => { b.executeSql(`DELETE FROM ${d.storeName}`, [], () => { a(); }, (a, b) => { c(b); }); }); }).catch(c); })); return j(c, a), c;
  } function S(a) {
    let b = this,
      c = new ja(((a, c) => { b.ready().then(() => { const d = b._dbInfo; d.db.transaction((b) => { b.executeSql(`SELECT COUNT(key) as c FROM ${d.storeName}`, [], (b, c) => { let d = c.rows.item(0).c; a(d); }, (a, b) => { c(b); }); }); }).catch(c); })); return j(c, a), c;
  } function T(a, b) {
    let c = this,
      d = new ja(((b, d) => { c.ready().then(() => { const e = c._dbInfo; e.db.transaction((c) => { c.executeSql(`SELECT key FROM ${e.storeName} WHERE id = ? LIMIT 1`, [a + 1], (a, c) => { let d = c.rows.length ? c.rows.item(0).key : null; b(d); }, (a, b) => { d(b); }); }); }).catch(d); })); return j(d, b), d;
  } function U(a) {
    let b = this,
      c = new ja(((a, c) => { b.ready().then(() => { const d = b._dbInfo; d.db.transaction((b) => { b.executeSql(`SELECT key FROM ${d.storeName}`, [], (b, c) => { for (var d = [], e = 0; e < c.rows.length; e++)d.push(c.rows.item(e).key); a(d); }, (a, b) => { c(b); }); }); }).catch(c); })); return j(c, a), c;
  } function V(a) {
    let b = this,
      c = {}; if (a) for (const d in a)c[d] = a[d]; return c.keyPrefix = `${c.name}/`, c.storeName !== b._defaultConfig.storeName && (c.keyPrefix += `${c.storeName}/`), b._dbInfo = c, c.serializer = Fa, ja.resolve();
  } function W(a) {
    let b = this,
      c = b.ready().then(() => { for (let a = b._dbInfo.keyPrefix, c = localStorage.length - 1; c >= 0; c--) { const d = localStorage.key(c); d.indexOf(a) === 0 && localStorage.removeItem(d); } }); return j(c, a), c;
  } function X(a, b) {
    const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = c.ready().then(() => {
      let b = c._dbInfo,
        d = localStorage.getItem(b.keyPrefix + a); return d && (d = b.serializer.deserialize(d)), d;
    }); return j(d, b), d;
  } function Y(a, b) {
    let c = this,
      d = c.ready().then(() => { for (let b = c._dbInfo, d = b.keyPrefix, e = d.length, f = localStorage.length, g = 1, h = 0; h < f; h++) { const i = localStorage.key(h); if (i.indexOf(d) === 0) { let j = localStorage.getItem(i); if (j && (j = b.serializer.deserialize(j)), j = a(j, i.substring(e), g++), void 0 !== j) return j; } } }); return j(d, b), d;
  } function Z(a, b) {
    let c = this,
      d = c.ready().then(() => {
        let b,
          d = c._dbInfo; try { b = localStorage.key(a); } catch (a) { b = null; } return b && (b = b.substring(d.keyPrefix.length)), b;
      }); return j(d, b), d;
  } function $(a) {
    let b = this,
      c = b.ready().then(() => { for (var a = b._dbInfo, c = localStorage.length, d = [], e = 0; e < c; e++)localStorage.key(e).indexOf(a.keyPrefix) === 0 && d.push(localStorage.key(e).substring(a.keyPrefix.length)); return d; }); return j(c, a), c;
  } function _(a) {
    let b = this,
      c = b.keys().then(a => a.length); return j(c, a), c;
  } function aa(a, b) { const c = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const d = c.ready().then(() => { const b = c._dbInfo; localStorage.removeItem(b.keyPrefix + a); }); return j(d, b), d; } function ba(a, b, c) { const d = this; typeof a !== 'string' && (console.warn(`${a} used as a key, but it is not a string.`), a = String(a)); const e = d.ready().then(() => { void 0 === b && (b = null); const c = b; return new ja(((e, f) => { const g = d._dbInfo; g.serializer.serialize(b, (b, d) => { if (d)f(d); else try { localStorage.setItem(g.keyPrefix + a, b), e(c); } catch (a) { a.name !== 'QuotaExceededError' && a.name !== 'NS_ERROR_DOM_QUOTA_REACHED' || f(a), f(a); } }); })); }); return j(e, c), e; } function ca(a, b) { a[b] = function () { const c = arguments; return a.ready().then(() => a[b](...c)); }; } function da() { for (let a = 1; a < arguments.length; a++) { const b = arguments[a]; if (b) for (const c in b)b.hasOwnProperty(c) && (Oa(b[c]) ? arguments[0][c] = b[c].slice() : arguments[0][c] = b[c]); } return arguments[0]; } function ea(a) { for (const b in Ja) if (Ja.hasOwnProperty(b) && Ja[b] === a) return !0; return !1; } var fa = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (a) { return typeof a; } : function (a) { return a && typeof Symbol === 'function' && a.constructor === Symbol && a !== Symbol.prototype ? 'symbol' : typeof a; },
    ga = e(); typeof Promise === 'undefined' && a(3); var ha,
    ia,
    ja = Promise,
    ka = 'local-forage-detect-blob-support',
    la = Object.prototype.toString,
    ma = { _driver: 'asyncStorage', _initStorage: y, iterate: A, getItem: z, setItem: B, removeItem: C, clear: D, length: E, key: F, keys: G },
    na = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    oa = '~~local_forage_type~',
    pa = /^~~local_forage_type~([^~]+)~/,
    qa = '__lfsc__:',
    ra = qa.length,
    sa = 'arbf',
    ta = 'blob',
    ua = 'si08',
    va = 'ui08',
    wa = 'uic8',
    xa = 'si16',
    ya = 'si32',
    za = 'ur16',
    Aa = 'ui32',
    Ba = 'fl32',
    Ca = 'fl64',
    Da = ra + sa.length,
    Ea = Object.prototype.toString,
    Fa = { serialize: J, deserialize: K, stringToBuffer: H, bufferToString: I },
    Ga = { _driver: 'webSQLStorage', _initStorage: L, iterate: N, getItem: M, setItem: P, removeItem: Q, clear: R, length: S, key: T, keys: U },
    Ha = { _driver: 'localStorageWrapper', _initStorage: V, iterate: Y, getItem: X, setItem: ba, removeItem: aa, clear: W, length: _, key: Z, keys: $ },
    Ia = {},
    Ja = { INDEXEDDB: 'asyncStorage', LOCALSTORAGE: 'localStorageWrapper', WEBSQL: 'webSQLStorage' },
    Ka = [Ja.INDEXEDDB, Ja.WEBSQL, Ja.LOCALSTORAGE],
    La = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'],
    Ma = { description: '', driver: Ka.slice(), name: 'localforage', size: 4980736, storeName: 'keyvaluepairs', version: 1 },
    Na = {}; Na[Ja.INDEXEDDB] = f(), Na[Ja.WEBSQL] = g(), Na[Ja.LOCALSTORAGE] = h(); var Oa = Array.isArray || function (a) { return Object.prototype.toString.call(a) === '[object Array]'; },
    Pa = (function () {
      function a(b) { d(this, a), this.INDEXEDDB = Ja.INDEXEDDB, this.LOCALSTORAGE = Ja.LOCALSTORAGE, this.WEBSQL = Ja.WEBSQL, this._defaultConfig = da({}, Ma), this._config = da({}, this._defaultConfig, b), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(() => {}); } return a.prototype.config = function (a) { if ((typeof a === 'undefined' ? 'undefined' : fa(a)) === 'object') { if (this._ready) return new Error("Can't call config() after localforage has been used."); for (const b in a) { if (b === 'storeName' && (a[b] = a[b].replace(/\W/g, '_')), b === 'version' && typeof a[b] !== 'number') return new Error('Database version must be a number.'); this._config[b] = a[b]; } return !('driver' in a && a.driver) || this.setDriver(this._config.driver); } return typeof a === 'string' ? this._config[a] : this._config; }, a.prototype.defineDriver = function (a, b, c) {
        const d = new ja(((b, c) => {
          try {
            let d = a._driver,
              e = new Error('Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver'),
              f = new Error(`Custom driver name already in use: ${a._driver}`); if (!a._driver) return void c(e); if (ea(a._driver)) return void c(f); for (let g = La.concat('_initStorage'), h = 0; h < g.length; h++) { const i = g[h]; if (!i || !a[i] || typeof a[i] !== 'function') return void c(e); } let j = ja.resolve(!0); '_support' in a && (j = a._support && typeof a._support === 'function' ? a._support() : ja.resolve(!!a._support)), j.then((c) => { Na[d] = c, Ia[d] = a, b(); }, c);
          } catch (a) { c(a); }
        })); return k(d, b, c), d;
      }, a.prototype.driver = function () { return this._driver || null; }, a.prototype.getDriver = function (a, b, c) {
        let d = this,
          e = ja.resolve().then(() => { if (!ea(a)) { if (Ia[a]) return Ia[a]; throw new Error('Driver not found.'); } switch (a) { case d.INDEXEDDB:return ma; case d.LOCALSTORAGE:return Ha; case d.WEBSQL:return Ga; } }); return k(e, b, c), e;
      }, a.prototype.getSerializer = function (a) { const b = ja.resolve(Fa); return k(b, a), b; }, a.prototype.ready = function (a) {
        let b = this,
          c = b._driverSet.then(() => b._ready === null && (b._ready = b._initDriver()), b._ready); return k(c, a, a), c;
      }, a.prototype.setDriver = function (a, b, c) {
        function d() { g._config.driver = g.driver(); } function e(a) { return g._extend(a), d(), g._ready = g._initStorage(g._config), g._ready; } function f(a) { return function () { function b() { for (;c < a.length;) { const f = a[c]; return c++, g._dbInfo = null, g._ready = null, g.getDriver(f).then(e).catch(b); }d(); const h = new Error('No available storage method found.'); return g._driverSet = ja.reject(h), g._driverSet; } var c = 0; return b(); }; } var g = this; Oa(a) || (a = [a]); let h = this._getSupportedDrivers(a),
          i = this._driverSet !== null ? this._driverSet.catch(() => ja.resolve()) : ja.resolve(); return this._driverSet = i.then(() => { const a = h[0]; return g._dbInfo = null, g._ready = null, g.getDriver(a).then((a) => { g._driver = a._driver, d(), g._wrapLibraryMethodsWithReady(), g._initDriver = f(h); }); }).catch(() => { d(); const a = new Error('No available storage method found.'); return g._driverSet = ja.reject(a), g._driverSet; }), k(this._driverSet, b, c), this._driverSet;
      }, a.prototype.supports = function (a) { return !!Na[a]; }, a.prototype._extend = function (a) { da(this, a); }, a.prototype._getSupportedDrivers = function (a) { for (var b = [], c = 0, d = a.length; c < d; c++) { const e = a[c]; this.supports(e) && b.push(e); } return b; }, a.prototype._wrapLibraryMethodsWithReady = function () { for (let a = 0; a < La.length; a++)ca(this, La[a]); }, a.prototype.createInstance = function (b) { return new a(b); }, a;
    }()),
    Qa = new Pa(); b.exports = Qa;
}, { 3: 3 }] }, {}, [4]))(4)));
